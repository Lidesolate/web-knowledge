## ES模块

### 模块解决了什么问题

在javascript中的编码就是管理变量。他的全部内容就是为变量赋值,或者向变量添加数字,或者将两个变量组合在一起并将他们放入另一个变量中。

![](https://hacks.mozilla.org/files/2018/03/01_variables-500x178.png)

因为你的代码中里有很多代码只是改变变量,所以如何组织这些变量会对代码的编码方式产生重大影响。

只需要考虑一些变量就可以让事情变得更容易,JavaScript有一种帮助你做到的机制,称之为作用域,函数无法访问到其他函数中定义的变量

![](https://hacks.mozilla.org/files/2018/03/02_module_scope_01-500x292.png)

但是这样也会有不好的地方,那就是很难在不同的函数之间共享变量

如果你想在作用域之外共享变量,处理此问题的常用方法是将其放在父作用域内,例如全局作用域中。

这很有效,但是也会产生一些问题

1. 首先,所有脚本必须按正确的顺序排列
2. 因为变量在全局范围内,所以在该全局范围内的代码的每个部分都可以更改变量。恶意代码可以故意更改变量,已使你的代码执行你不想要的操作,或者非恶意代码可能会意外的破坏你的变量

### 模块如何帮助

模块为您提供了组织这些变量和函数的更好的方法,使用模块,您可以将有意义的变量和函数组合在一起

这将这些函数和变量放入模块作用域内,模块作用域可用于在模块中的函数之间共享变量

但与函数作用域不同,模块作用域也有一种方法可以使其变量可用于其他模块。他们可以明确的说明模块中的那些变量,类或函数应该可用

当某些东西可供其他模块使用时,他被称为导出。一旦有了导出,其他模块就可以明确的他们依赖于那个变量,类或函数

![](https://hacks.mozilla.org/files/2018/03/02_module_scope_04-500x450.png)

一旦能够在模块之间导出和导入变量,就可以更轻松的将代码分解成为可以彼此独立工作的小块。然后,您可以组合并重新组合这些块,从同一组模块创建所有不同类型的应用程序。

由于模块非常有用。因此曾经很多人尝试向JavaScript添加模块系统。今天有两个模块系统正在积极使用,node使用的commonjs系统和浏览器支持的ES模块

### ES模块的工作原理

在使用模块进行开发时,可以构建依赖关系图,不同依赖项之间的连接来自您使用的任何`import`语句。

这些`import`语句时浏览器或node如何准确知道需要加载的代码。您可以为其提供一个文件,以用作图表的入口点。从哪里他只是跟随任何`import`语句查找其余的代码

![](https://hacks.mozilla.org/files/2018/03/04_import_graph-500x291.png)

但文件本身并不是浏览器可以使用的东西,他需要解析所有这些文件,将他们转换为名为`Module Records`的数据结构,这样，他实际上知道文件中发生了什么

![](https://hacks.mozilla.org/files/2018/03/05_module_record-500x287.png)

之后,需要将模块记录转换为模块实例。一个实例结合了两件事: 代码和状态

代码基本上是一组指令。就像是如何制作东西的食谱,但就其本身而言,您无法使用代码执行任何操作,你需要使用原材料来使用食谱。状态会为你提供这些原材料,状态是任何时间点变量的实际值。当然,这些变量只是内存中用于保存值得昵称

因此模块实例将代码(指令列表)与状态(所有变量得值)组合在一起

![](https://hacks.mozilla.org/files/2018/03/06_module_instance-500x372.png)

我们需要得是每个模块得模块实例。模块加载过程从此入口文件到模块实例得完整图表

对于ES模块,这分三步进行
1. 构造-查找: 下载并将所有文件解析为模块记录
2. 实例化: 内存中找到模块以将所有导出得值放入(但不用值填充他们)
3. 评估: 运行代码已使用变量的实际值填充框

![](https://hacks.mozilla.org/files/2018/03/07_3_phases-500x184.png)

### 构造-查找

在构造-查找阶段,每个模块都会发生三件事

1. 找出从哪里下载包含模块的文件
2. 获取文件
3. 将文件解析为模块记录

#### 查找文件并获取它

加载器负责查找文件并下载。首先,他需要找到入口点文件。在HTML中,您可以使用脚本标记告诉加载程序在何处找到它。

![](https://hacks.mozilla.org/files/2018/03/08_script_entry-500x188.png)

但它如何找到下一批模块,`main.js`直接依赖的模块

这是`import`语句的用武之地,`import`语句的一部分称为模块说明符,他告诉加载器他可以在哪里找到每个下一个模块

![](https://hacks.mozilla.org/files/2018/03/09_module_specifier-500x105.png)

在解析文件之前,您不知道模块需要获取那些依赖项,并且在获取文件之前无法解析该文件

这意味着我们必须逐层遍历树,解析一个文件,然后找出他的依赖关系,然后查找并加载这些依赖关系

![](https://hacks.mozilla.org/files/2018/03/10_construction-500x302.png)

如果主线程要等待下载这些文件中的每一个,那么许多其他任务将堆积在队列中。

![](https://hacks.mozilla.org/files/2018/03/11_latency-500x270.png)

像这样阻塞主线程会使使用模块的应用程序太慢而无法使用。这是ES模块规范将算法分成多个阶段的原因之一,允许浏览器获取文件并建立对模块图的而理解,然后在进行实例化的同步工作

而CommonJs采取不同的做法,因为从文件系统加载文件所需的时间比通过`internet`下载要少的多,这意味着`Node`可以在加载文件时阻止主线程。由于文件已经加载,因此只需要实例化和评估,这也意味着在返回模块实例之前,您正在遍历整个树,加载,实例化和评估任何依赖项。

![](https://hacks.mozilla.org/files/2018/03/12_cjs_require-500x298.png)


#### 解析

现在我们已经获取了这个文件,我们需要将他解析为模块记录,这有助于浏览器了解模块的不同部分。

![](https://hacks.mozilla.org/files/2018/03/25_file_to_module_record-500x199.png)

创建模块记录后,他将被放置在模块映射中。这意味着无论何时从这里开始请求,加载器可以从该映射中提取他。

![](https://hacks.mozilla.org/files/2018/03/25_module_map-500x239.png)

#### 实例化

一个实例将代码与状态相结合。改状态存在于内存中,因此实例化步骤就是将内容连接到内存。

首先, JS引擎创建模块环境记录。这管理模块记录的变量。然后他在内存中找到所有导出的框。模块环境记录将跟踪内存中的那个框与每个导出相关联

内存中的这些框将无法获得其值。只有在评估之后才能填写他们的实际值。

为了实例化模块图,引擎将执行所谓的深度优先遍历。这意味着他将深入到图表的底部,底部依赖于其他任何东西的依赖关系,并设置他们的导出。

![](https://hacks.mozilla.org/files/2018/03/30_live_bindings_01-500x206.png)

引擎完成了模块下所有导出的连接-模块所依赖的所有导出。然后他返回一个引用来连接该模块的导入。

请注意,导出和导入都指向内存中的相同位置。首先确保出口的连接可以保证所有进口都可以连接到匹配的出口。

![](https://hacks.mozilla.org/files/2018/03/30_live_bindings_02-500x206.png)

这与CommonJs模块不同。在CommonJs中,整个导出对象在导出时复制。这意味着导出的任何值都是副本

这意味着如果导出模块稍后更改该值,则导入模块不会看到该更改

![](https://hacks.mozilla.org/files/2018/03/31_cjs_variable-500x113.png)

相比之下,ES模块使用称为活动绑定的东西。两个模块都执行内存中相同位置。这意味着当导出模块更改值时,该更改将显示在导入模块中。

导出值得模块可以随时更改这些值,但导入模块不能更改其导入得值。

#### 评估

最后一步实在内存中填入这些框,JS通过执行顶级代码(函数之外得代码)来完成此操作

除了在内存中填充这些框之外,评估代码可以触发副作用。例如, 模块可能会调用服务器。

![](https://hacks.mozilla.org/files/2018/03/40_top_level_code-500x146.png)

这是获得模块映射得一个原因,模块映射通过规范URL缓存模块,以便，每个模块只有一个模块记录。这确保每个模块仅执行一次。与实例化一样,这是作为深度优先得后序遍历完成得。

在循环依赖中,最终会在图中出现循环。

![](https://hacks.mozilla.org/files/2018/03/41_cjs_cycle-500x224.png)

让我们来看看它如何与CommonJs模块一起使用。首先,主模块将执行`require`语句。然后他会加载计数器模块

![](https://hacks.mozilla.org/files/2018/03/41_cyclic_graph-500x281.png)

然后计数器模块将尝试`message`从导出对象进行访问。但由于尚未在主模块中进行评估,因此将返回`undefeind`。js引擎将在内存中为局部变量分配空间,并将值设置为`undefined`

评估一直持续到计数器模块得顶级代码结束,我们想看看我们是否最终会得到正确的消息值（在评估main.js之后），所以我们设置了一个超时。然后评估恢复main.js。

![](https://hacks.mozilla.org/files/2018/03/43_cjs_cycle-500x224.png)

消息变量将被初始化并添加到内存中。但由于两者之间没有任何联系，因此它将在所需模块中保持未定义状态。

![](https://hacks.mozilla.org/files/2018/03/44_cjs_variable_2-500x216.png)

如果使用实时绑定处理导出，则计数器模块最终会看到正确的值。到超时运行时，main.js评估将完成并填入值。

支持这些周期是ES模块设计背后的一个重要原因。正是这种三相设计使它们成为可能。