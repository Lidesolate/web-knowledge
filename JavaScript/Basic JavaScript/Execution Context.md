## 执行上下文

**概述**:

为执行 JS 代码,并跟踪其运行时求值,JavaScript 规范定义了执行上下文的概念。从逻辑上讲,执行上下文是用栈来维护的,栈与调用栈这个通用概念有关

JavaScript 有几种类型: 全局代码,函数代码,`eval`代码和模块代码;每种代码都在其执行上下文中求值。不同的代码类型及其对应的对象可能会影响执行上下文的结构: 比如`generator`函数将其`generator`对象保存在上下文中

考虑下面的一个递归函数调用

```
function recursive(flag){
  if(flag === 2){
    return;
  }

  recursive(++flag);
}

recursive(0);
```

当函数被调用的时,就创建了一个新的执行上下文,并被压到栈中-此时他变成一个活动的执行上下文。当函数返回时,其上下文被从栈中弹出

调用另一个上下文的上下文被称为调用者(caller)。被调用的上下文相应地被称为被调用者(callee)。在我们的例子中,`recursive`函数在递归调用他本身时,同时扮演了这两个角色: 既是调用者,又是被调用者

**执行上下文堆栈**: 执行上下文栈是一种 LIFO(后进先出)结构,用于维护控制流程和执行顺序

![]('http://www.xiaojichao.com/static/upload/20171215/pVd7fNaNvTzy_r_jWCk3.png')

我们还可以了解到,全局上下文总是在栈的底部,他是由之前任何其他上下文的执行创建的

通常一个上下文的代码会一直运行到结束,不过正如我们上面提到过的,有些对象,比如`generator`,可能会违反栈的 LIFO 顺序,一个`generator`函数可能会挂起其正在执行的上下文的,并在其结束前将其从栈中删除。一旦`generator`再次激活,他上下文就被回复,并再次压入栈中

```
function *gen(){
  yield 1;
  return 2;
}

let g = gen();

console.log(
  g.next().value; 1
  g.next().value; 2
)
```

这里的`yield`语句将值返回给调用者,并弹出上下文。在第二个`next`调用时,同一个上下文被再次压入栈中,并恢复。这样的上下文可能会比创建他的调用者活的长,所以会违反 LIFO 结构

### 作用域

每个执行上下文都一个相关联的词法环境。

**词法环境**: 词法环境是一种用于定义出现在上下文中的标识符于其值之间的关联的结构。每个环境有一个对可选的父环境的引用

所以,环境就是定义在一个作用域中的变量,函数和类的存储

从技术上讲,环境是由一对环境记录(一个将标识符映射到值的实际存储表)以及对父的引用可能是`null`组成的

对于如下代码:

```
let x = 10;
let y = 20;

function foo(z){
  let x = 100;
  return x + y + z;
}

foo(30);
```

全局上下文以及`foo`函数的上下文的环境结构看起来会像下面这样

![]('http://www.xiaojichao.com/static/upload/20171215/_4_iCT4i2nWck7DXOB3_.png')

变量查找的时候会产生变量屏蔽的规则: 如果一个变量在自己的环境中找不到,就试着在父环境,父环境中的父环境中查找他,以此类推,直到查完整个环境链。这就解释了我们为什么还可以去访问变量 y,因为他是在父环境中找到的。

环境记录根据类型而用所不同。有对象环境记录和声明式环境记录。在声明式记录上,还有函数环境记录和模块环境记录。每种类型的记录都有其特定的属性。不过标识符解析的通用机制对于所有环境都是通用的,并且不依赖于记录的类型

全局环境的记录就是对象环境记录的一个例子。这样的记录也有关联的绑定对象,该对象会存储一些来自该记录的属性,但是不会存储来自其他记录的属性反之亦然。绑定对象也可以被提供`this`值

```
var x = 10;
let y = 20;

console.log(
  x, // 10
  y  // 20
)

// 只有x被添加到绑定对象
// 全局环境的绑定对象相当于`this`

console.log(
  this.x // 10
  this.y // undefined
)

// 绑定对象可以存储一个名成,该名称不添加到环境记录

this['not valid ID'] = 30;

console.log(
  this['not valid ID'], // 30
)
```

![]('http://www.xiaojichao.com/static/upload/20171215/tJEx2IUIGj7bocEq3rL3.png')

注意,绑定对象的存在是为了涵盖以前的构造(比如`var`声明和`with`语句),这种构造也将其对象作为绑定对象提供。

### 变量查询

在 JavaScript 中,变量的赋值操作会执行两个动作,首先编译器会在当前作用域中声明一个变量(如果之前没有声明过),然后在运行时引擎会在作用域中查找该变量,如果能找到就会对他进行赋值。查找的过程由作用域进行协助,但是引擎执行怎样的查找,会影响最终的查找结果。
而在这个声明语句中`var a = 2`引擎会为变量`a`进行`LHS`查询,另外一个查找的类型叫做`RHS`。当变量出现在赋值操作的左侧时进行`LHS`查询,出现在右侧时进行`RHS`查询。更准确一点，
**RHS 查询与简单的查找某个变量的值别无二至,而 LHS 查询则是试图找到变量的容器本身,从而可以对其及进行赋值**
考虑下面的程序,其中既有`LHS`也有`RHS`引用

```
function foo(a){
  console.log(a); //2
}

foo(2);
```

最后一行`foo(...)`函数的调用需要对`foo`进行`RHS`引用,意味着去找到 foo 的值,并把他给我。而当`2`被当作参数传递给`foo(...)`函数时,`2`会被分配给参数`a`。为了参数`a`(隐式的)分配值,需要进行一次`LHS`查询,这里还有对 a 进行的`RHS`引用,将得到的值传给了`console.log(...)`。`console.log(...)`本身也需要一个引用能够执行,因此会对`console`对象进行`RHS`查询,并且检查得到的值中是否有一个叫做`log`的方法。

### 变量提升

在 JavaScript 中存在变量提升的现象,如下

```
console.log(a); // undefiend

var a = 2;
```

至于为什么会造成这个现象,会将声明语句`var a = 2`看成两个声明: `var a`和`a = 2`。第一个定义声明是在编译阶段进行的,第二个赋值声明会被留在原地等待执行阶段,具体的处理如下

1.  遇到`var a`编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的集合当中。如果是,编译器会忽略该声明,继续进行编译,否则他会要求作用域的集合中声明一个新的变量。并命名为`a`
2.  接下来编译器会为引擎生成运行时所需的代码,这些代码被用来处理`a = 2`这个赋值操作。引擎运行时会首先询问作用域,在当前的作用域集合中是否存在一个叫做`a`的变量,如果是,引擎就会使用那个变量,如果否,引擎会随着作用域链继续查找该变量。如果最终找到该变量,就会将`2`赋值给他。否则引擎会继续查找该变量。
    **总结: 包括变量和函数在内的所有声明都会在任何代码被执行前首先被处理**
    因此之前的代码片段会进行这样的处理

```
var a;
console.log(a);
a = 2;
```

值得注意的是,函数声明会提升,函数表达式却不会被提升

```
foo(); // TypeError
var foo = function bar(){...}
```

函数声明和变量声明都会提升，但是一个值得注意的细节是函数首先会被提升,然后才是变量

```
foo(); //1
var foo;
function foo(){
  console.log(1);
}
foo = function(){
  console.log(2);
}
```

### 块作用域

在 ES6 之前 JavaScript 是没有块作用域,因此会造成某些问题

```
if(true){
  var a = 3;
}
console.log(a); // 3
```

我们只想变量`a`在`if`语句块内使用,然而他却会绑定在外部作用域中。这会造成一个结果,开发者需要小心的检查自己的代码,以防止在作用域外意外的使用某些变量。

而在 ES6 新的变量声明`let`和`const`关键字解决了这个问题。
`let`和`const`关键字可以将变量绑定到所在的任意作用域中(通常是`{...}`内部),也就意味着`let`为其声明的变量隐式的劫持了所在的块作用域。

```
if(true){
  let a = 3;
}
console.log(a); // referenceError;
```

而`let`另一个优势就是在循环中,例如

```
var a = [];
for(var i = 0; i < 10; i++){
  a[i] = function(){
    console.log(i);
  }
}
a[0](); // 10
```

由于`i`是由`var`声明的,因此全局作用域都有效,而全局只有一个变量`i`,因此每当执行函数,`RHS`查询都查询最后一次循环所改变的变量`i`。
在`let`关键字之前我们为了规避这种现象,通常使用自执行函数来形成独自的作用域。

```
var a = [];
for(var i = 0; i < 10; i++){
  (function(i){
    a[i] = function(){
      console.log(i)
    }
  })(i)
};
a[2]() // 2
```

而新出现的`let`关键字的特性不仅将`i`绑定到了 for 循环的块中,事实上将其重新绑定到了循环的每一个迭代中,确保使用上一个循环迭代结束时的值重新进行赋值

```
let a = [];
for(let i = 0; i < 10; i++){
  a[i] = function(){
    console.log(i)
  }
}
a[10]() // 10
```

此外在`let`和`const`还有区别于`var`的地方

- 不存在变量提升:

`var`变量会发生变量提升现象,即变量可以在声明之前使用,值为`undefeind`。不过这种现象会导致某些问题。为了纠正这种现象
`let`命令改变了语法行为,他所声明的变量一定要在声明后使用,否则报错。

```
console.log(foo); // 输出undefined
var foo = 2;

// let的情况
console.log(bar); // 报错
let bar = 2;
```

- 暂时性死区:

只要块级作用域存在`let`命令,他所声明的变量就绑定这个区域,不在受外部的影响

```
var temp = 123;
if(true){
  temp = 'abc'; // ReferenceError;
  let temp
}
```

ES6 明确规定,如果区块中存在`let`和`const`命令,这个区对这些命令声明的变量,从一开始就形成了封闭作用域,凡是在声明之前就使用这些变量,就会报错。我们称之为暂时性死区

```
if(true){
  // TDZ开始
  tmp = 'abc'; // ReferenceError
  console.log(tmp); // ReferenceError

  let tmp; // TDZ结束
  console.log(tmp); // undefined

  tmp = 123;
  console.log(tmp); // 123
}
```

- 不允许重复声明

`let`不允许在相同作用域内,重复声明同一个变量

```
// error
function func(){
  let a = 10;
  var a = 1;
}
// error
function func(){
  let a = 10;
  let a = 1;
}
```

因此不能在函数内部重新声明参数

```
function func(arg){
  let arg // error
}
function func(arg){
  {
    let arg; // 不报错
  }
}
```

- `const`值的常量性:

`const`声明一个只读的常量,一旦声明,常量的值就不能改变。不过是相对于基本类型而言,而对于引用类型来说却不一样

```
const PI = 3.14;
PI = 3; // TypeError

const foo = {};
foo.a = 1;
foo = {}; // TypeError
```

`const`的本质,并不是变量的值不得改动,而是变量指向的那个内存地址不得改动。对于引用类型而言,`const`能保证的是这个指针的是固定的,至于他指定的数据结构是不是可变的,就完全不能控制的。
而如果我们需要将一个对象完全不可变,我们需要用到`Object.freeze()`函数。

```
let constantize = (obj) => {
  Object.freeze(obj);
  Object.keys(obj).forEach(key => {
    if(typeof obj[key] === 'object'){
      constantize(obj[key])
    }
  })
}
```

### 闭包

### this
