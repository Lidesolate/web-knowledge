## 执行上下文

**概述**:

为执行 JS 代码,并跟踪其运行时求值,JavaScript 规范定义了执行上下文的概念。从逻辑上讲,执行上下文是用栈来维护的,栈与调用栈这个通用概念有关

JavaScript 有几种类型: 全局代码,函数代码,`eval`代码和模块代码;每种代码都在其执行上下文中求值。不同的代码类型及其对应的对象可能会影响执行上下文的结构: 比如`generator`函数将其`generator`对象保存在上下文中

考虑下面的一个递归函数调用

```
function recursive(flag){
  if(flag === 2){
    return;
  }

  recursive(++flag);
}

recursive(0);
```

当函数被调用的时,就创建了一个新的执行上下文,并被压到栈中-此时他变成一个活动的执行上下文。当函数返回时,其上下文被从栈中弹出

调用另一个上下文的上下文被称为调用者(caller)。被调用的上下文相应地被称为被调用者(callee)。在我们的例子中,`recursive`函数在递归调用他本身时,同时扮演了这两个角色: 既是调用者,又是被调用者

**执行上下文堆栈**: 执行上下文栈是一种 LIFO(后进先出)结构,用于维护控制流程和执行顺序

![]('http://www.xiaojichao.com/static/upload/20171215/pVd7fNaNvTzy_r_jWCk3.png')

我们还可以了解到,全局上下文总是在栈的底部,他是由之前任何其他上下文的执行创建的

通常一个上下文的代码会一直运行到结束,不过正如我们上面提到过的,有些对象,比如`generator`,可能会违反栈的 LIFO 顺序,一个`generator`函数可能会挂起其正在执行的上下文的,并在其结束前将其从栈中删除。一旦`generator`再次激活,他上下文就被回复,并再次压入栈中

```
function *gen(){
  yield 1;
  return 2;
}

let g = gen();

console.log(
  g.next().value; 1
  g.next().value; 2
)
```

这里的`yield`语句将值返回给调用者,并弹出上下文。在第二个`next`调用时,同一个上下文被再次压入栈中,并恢复。这样的上下文可能会比创建他的调用者活的长,所以会违反 LIFO 结构

### 作用域

每个执行上下文都一个相关联的词法环境。

**词法环境**: 词法环境是一种用于定义出现在上下文中的标识符于其值之间的关联的结构。每个环境有一个对可选的父环境的引用

所以,环境就是定义在一个作用域中的变量,函数和类的存储

从技术上讲,环境是由一对环境记录(一个将标识符映射到值的实际存储表)以及对父的引用可能是`null`组成的

对于如下代码:

```
let x = 10;
let y = 20;

function foo(z){
  let x = 100;
  return x + y + z;
}

foo(30);
```

全局上下文以及`foo`函数的上下文的环境结构看起来会像下面这样

![]('http://www.xiaojichao.com/static/upload/20171215/_4_iCT4i2nWck7DXOB3_.png')

变量查找的时候会产生变量屏蔽的规则: 如果一个变量在自己的环境中找不到,就试着在父环境,父环境中的父环境中查找他,以此类推,直到查完整个环境链。这就解释了我们为什么还可以去访问变量 y,因为他是在父环境中找到的。

环境记录根据类型而用所不同。有对象环境记录和声明式环境记录。在声明式记录上,还有函数环境记录和模块环境记录。每种类型的记录都有其特定的属性。不过标识符解析的通用机制对于所有环境都是通用的,并且不依赖于记录的类型

全局环境的记录就是对象环境记录的一个例子。这样的记录也有关联的绑定对象,该对象会存储一些来自该记录的属性,但是不会存储来自其他记录的属性反之亦然。绑定对象也可以被提供`this`值

```
var x = 10;
let y = 20;

console.log(
  x, // 10
  y  // 20
)

// 只有x被添加到绑定对象
// 全局环境的绑定对象相当于`this`

console.log(
  this.x // 10
  this.y // undefined
)

// 绑定对象可以存储一个名成,该名称不添加到环境记录

this['not valid ID'] = 30;

console.log(
  this['not valid ID'], // 30
)
```

![](http://www.xiaojichao.com/static/upload/20171215/tJEx2IUIGj7bocEq3rL3.png)

注意,绑定对象的存在是为了涵盖以前的构造(比如`var`声明和`with`语句),这种构造也将其对象作为绑定对象提供。
