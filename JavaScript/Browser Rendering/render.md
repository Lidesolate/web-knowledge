## 浏览器渲染原理

### 浏览器主要组成与浏览器线程

#### 浏览器组件

浏览器大体上由以下几个组件组成,各个浏览器可能由一点不同

![](https://segmentfault.com/img/bV2xGZ?w=400&h=271)

+ 界面控件: 包括地址栏,前进后退,书签菜单等窗口上除了网页显示区域以外的部分
+ 浏览器引擎: 查询与操作渲染引擎的接口
+ 渲染引擎: 负责显示请求的内容,比如请求到`HTML`,他会负责解析HTML,CSS并将结果显示到窗口中
+ 网络: 用于网络请求,如HTTP请求。他包括平台无关的接口和各平台独立的实现
+ UI后端: 绘制基础原件,如组合框与窗口,它提供平添无关的接口,内部使用操作系统的相应实现
+ js解析器: 用于解析执行JavaScript代码
+ 数据存储持久层: 浏览器需要把所有数据存到硬盘上,如`cookies`。

#### 浏览器中的线程

1. GUI渲染线程: GUI渲染线程负责渲染浏览器界面HTML元素,当界面需要重绘或由于某种操作引发回流时,该线程就会执行,在JavaScript引擎运行脚本期间,GUI渲染线程都是处于挂起状态的,也就是说被冻结了

2. JavaScript引擎线程

js为处理界面用户的交互,以及操作DOM树,CSS样式树来给用户呈现一份动态而丰富的交互体验和服务器逻辑的交互处理。如果JS时多线程的方式来操作这些UI DOM,则可能出现UI操作的冲突;

3. 定时器触发器线程

浏览器定时器并不是由JS引擎计数的,因为JS引擎时单线程的,如果处于阻塞线程状态就会影响计时的准确,因此通过单独线程来计时并触发定时是更为合理的方案

4. 事件触发线程:

当一个时间被触发时该线程会把事件添加到待处理队列的队尾,等待JS引擎的处理。这些事件可以是当前执行的代码块如定时任务,也可来自浏览器内核的其他线程如鼠标点击,AJAX异步请求等,但由于JS的单线程关系所有这些事件都得排队等待JS引擎处理

5. 异步HTTP请求线程:

在XMLHttpRequest在连接后时通过浏览器新开一个线程请求,将检测到状态变更时,如果设置有回调函数,异步线程就产生状态变更事件放到JS引擎的处理队列中等待处理

### 渲染过程

用户请求的HTML文本通过浏览器的网络层到达渲染引擎后,渲染工作开始,其中渲染流程图如下

![](https://segmentfault.com/img/bV2xG8?w=624&h=289)

渲染过程一般有四个主要步骤:

1. 解析HTML生成DOM树: 渲染引擎首先解析HTML文档,生成DOM树
2. 构建Render树: 接下来不管是内联式,外联式还是嵌入式引入的CSS样式会被解析生成CSSOM树,根据DOM树与CSSOM树生成另外一棵用于渲染的树,渲染树
3. 布局Render树: 然后对渲染树的每个节点进行布局处理,确定其在屏幕上的显示位置
4. 绘制Render树: 最后遍历渲染树并用UI后端层将每个节点绘制出来。

#### 构建DOM树

浏览器会逐行代码构建DOM,只要第一行代码进来,他就开始解析HTML,向树结构添加节点

![](https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/09/ezgif-2-2688553063.gif)

具体的构建过程:
1. 转换: 浏览器从磁盘或网络中读取HTML的原始字节,并根据文件的指定编码生成字符串
2. 标签化: 标签转换成定义其属性和规则的对象
3. 词法分析: 标签转换成定义其属性和规则的对象
4. DOM构建: 在HTML中,嵌套定义了不同标签之间的父子关系。在DOM中,对象被连接到捕获这些关系的树数据结构中。每个HTML标记都由一个DOM节点

![](https://user-gold-cdn.xitu.io/2018/4/16/162cd0ae86a8d936?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

#### 构建CSSOM树

在HTML中的CSS样式会被解析成CSSOM(CSS对象模型)。

![](https://user-gold-cdn.xitu.io/2018/4/16/162cd0ae55370e36?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

他非常像DOM,但与DOM不同,他不能逐步构建,由于CSS规则可以相互覆盖,因此浏览器疫引擎必须进行复杂运算才能确定CSS如何引用DOM中,也就是说只有把CSS全部加载完才能构建CSSOM对象模型,但这样会阻塞页面渲染

与处理HTML时一样,我们需要将收到的CSS规则转换成浏览器能够理解和处理的东西。因此我们会重复构建DOM对象过程,不过是为了CSS而不是DOM

![](https://user-gold-cdn.xitu.io/2018/4/16/162cd0ae7e5670e7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

最后会生成一个CSSOM对象模型的树结构

![](https://user-gold-cdn.xitu.io/2018/4/16/162cd0ae812982f0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

#### 构建Render树

为了构建渲染树,浏览器大体上完成了下列工作

1. 从DOM的根节点开始遍历每个可见节点,某些节点不可见(例如脚本标记,元标记等),因为他们不会体现在渲染输出中,所以会被隐藏,某些节点通过CSS隐藏,因此在渲染树中也会被隐藏,例如`display: none`
2. 对于每个可见节点,为其找到适配的CSSOM规则并应用他们
3. 构建可见节点,连同其内容和计算的样式

![](https://segmentfault.com/img/bV2xHi?w=500&h=271)

**注意**: `visibility: hidden`与`display: none`是不一样的,前者隐藏元素,但元素仍占据着布局空间(即将其渲染成一个空的盒子),而后者则将元素从渲染树中完全移除,元素即不可见,也不是布局的组成部分

#### 布局Render树与绘制Render树

有了渲染树,我们就可以进入布局阶段,到目前位置,我们计算了那些节点应该是可见的以及他们的计算样式,但我们尚未计算他们在设备视口内的确切位置和大小,这就是布局阶段,也成为重排

HTML采用基于流的布局模型,这意味这大多数情况下只要一次遍历就能计算出几何信息,处于流中靠后元素通常不会影响构建前位置元素的几何特征,因此布局可以按从左到右,从上到下的顺序遍历文档。

在绘制阶段,系统会遍历渲染树,将渲染树的内容显示在屏幕上

#### 回流和重绘

**回流**(reflow): 当浏览器发生某个部分变化影响了布局,需要从头渲染整个页面,从`<html>`这个根节点递归往下,依次计算所有的节点几何尺寸和位置。`reflow`几乎是无可避免的。只要是引起页面上某些元素的占位面积,定位方式,边距等属性的变化,都会引起它内部,周围甚至整个页面的重新渲染

**重绘(repaint)**: 改变某个元素的背景色,文字颜色,边框颜色等等不影响他周围或内部布局的属性时,屏幕的一部分要重绘,但是元素的几何尺寸没有变。

**reflow与repaint的时机**: 

1. `display: none`会触发`reflow`,而`visibilty: hidden`只会触发`repaint`,因为没有发生位置变化
2. 有些情况下,比如修改了元素的样式,浏览器并不会里可`reflow`或`repaint`一次,而是把这样的操作积攒一批,然后做一个`reflow`,这叫异步reflow
3. 有些情况下,比如`resize`窗口,改变了页面默认的字体等,对于这些操作,浏览器会马上进行`reflow`

### 阻塞问题

#### JavaScript阻塞问题

当浏览器构建DOM时,如果遇到`<script></script>`HTML中的标记,他必须立即执行它,如果脚本是外部脚本,则必须先下载脚本,因此会停止对HTML的解析,只有在JavaScript引擎从脚本执行代码后再次启动

![](https://hacks.mozilla.org/files/2017/09/script-bold@2x-500x150.png)

至于解析停止的原因是,脚本可以改变HTML及其产生的DOM对象模型,脚本可以通过添加节点来更改DOM结构`document.createElement()`。要更改HTML,脚本可以使用`document.write()`功能添加内容。他可以影响进一步解析的方式更改HTML,例如,该函数可以插入一个开始注释标记,使HTML的其余部分无效

![](https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/09/image.gif)

脚本还可以查询有关DOM的内容,如果在构建DOM时发生这种情况,则可能返回意外结果

#### CSS阻塞问题

JavaScript阻止解析,因为他可以去修改文档,CSS无法修改文档,因此似乎没有理由阻止解析,但是,如果脚本要求尚未解析的样式信息,该怎么办?浏览器不知道脚本执行什么,例如通过`dom`中的`style`属性访问CSS样式。

![](https://hacks.mozilla.org/files/2017/09/assembling-2-500x302.png)

因此CSS可能会阻止解析,具体取决于文档中外部样式表和脚本的顺序,如果在文档中的脚本之前放置了外部样式表,则DOM和CSSOM对象构造可能会相互干扰。在JavaScript完成执行之前。DOM构造无法继续,并且在CSS下载,解析并且CSSOM可用之前,JavaScript无法执行。

![](https://hacks.mozilla.org/files/2017/09/blocking-bold@2x-1-500x162.png)

#### defer 和 async

如上所述,并非所有脚本对于用户体验都同样重要,例如跟踪和分析的脚本,我们可以异步加载这些不太重要的脚本

通过`defer`和`async`这两个属性,可以告诉浏览器,它可以在后台加载脚本时继续解析HTML,然后再加载后执行脚本。这样,脚本下载不会阻止DOM构造和页面呈现。用户可以在所有脚本完成加载之前查看页面

至于两者的区别是在他们开始执行脚本的那一刻,在此之前我们需要了解以下再浏览器加载HTML中一些事件

![](https://user-gold-cdn.xitu.io/2018/4/16/162cd0af4a54bb2a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

+ `domLoading`: 浏览器即将开始解析第一批收到的HTML文档字节
+ `domInteractive`: 表示浏览器完成对所有HTML的解析并且DOM构建完成的时间点
+ `domContentLoaded`: 表示DOM准备就绪并且没有样式表阻止JavaScript执行的时间点
+ `domComplete`: 所有处理完成,并且网页上的所有资源都已经下载完毕
+ `loadEvent`: 作为每个网页加载的最后一步,浏览器会触发`onload`事件,以便触发额外的应用逻辑

`defer`都会在页面解析完毕之前,按照原本的顺序执行,但是在`domContentLoaded`事件发生之前执行

![](https://hacks.mozilla.org/files/2017/09/defer-bold@2x-500x164.png)

`async`则会在完成下载后就会立刻执行,同时会在`window.load`事件之前执行,因此就可能会出现脚本可能不会按他们再HTML中出现的顺序执行,这也意味着他们可以中断DOM构建

无论在何处指定，async脚本都以低优先级加载。它们通常在所有其他脚本之后加载，而不会阻止DOM构建。但是，如果async脚本更快完成下载，则其执行可以阻止DOM构建以及之后完成下载的所有同步脚本。

![](https://hacks.mozilla.org/files/2017/09/async-bold@2x-500x151.png)

#### preload

preload能够让浏览器提前加载执行资源(加载后并不执行),再需要的时候在执行

+ 将加载和执行分离开,可不阻塞渲染和domcument的`onload`事件
+ 提前加载执行资源,不在出现依赖的`font`字体隔了一段时间才刷出

我们可以通过link 标签创建
```
<link rel="preload" href="/path/style.css" as="style">
```












